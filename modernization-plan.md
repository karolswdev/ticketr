### **Ticketr v2.0: A Modernization and Evolution Plan**

**Document Version:** 1.0
**Date:** 2025-08-27
**Author:** The Architect

#### **1. Strategic Vision: The "Tickets-as-Code" Control Plane**

The modernization of Ticketr is guided by a singular vision: to evolve it from a simple command-line utility into a **declarative control plane for agile project management**. The core principle is "Tickets-as-Code," where the version-controlled Markdown file becomes the canonical source of truth for all project planning and work-item definition. The web UI becomes a secondary interface for status updates and comments, while the strategic definition, creation, and structuring of work happens within the developer's native Git-based workflow.

To achieve this, Ticketr v2.0 will abandon its `Story`-centric model in favor of a **generic, schema-aware architecture**. It will no longer have hardcoded assumptions about issue types or fields. Instead, it will learn the specific schema of its target Jira instance and use a user-managed configuration file to dynamically map human-readable Markdown definitions to the precise JSON payloads required by the Jira API. This new architecture will be underpinned by a powerful hierarchical field inheritance model, enabling both consistency and flexibility in defining complex work breakdowns. The ultimate goal is a tool that is not merely a "Jira story creator" but a fully bidirectional synchronization engine that makes managing Jira as seamless and auditable as managing code.

#### **2. The Canonical Schemas**

These schemas represent the new, non-negotiable data contracts for Ticketr v2.0. All development must adhere to these structures.

##### **2.1. The Unified `TICKET` Markdown Schema**

The fundamental unit of work will now be a `# TICKET:` block. This schema introduces a dedicated `## Fields` section and supports full definitions for nested tasks.

```markdown
# TICKET: [Optional JIRA-ID] Title of the work item

## Description
A multi-line, Markdown-enabled description of the ticket.

## Fields
# This section contains all structured metadata.
# Fields defined here are inherited by all child tasks.
Type: Story | Bug | Task | etc.
Project: <PROJECT_KEY>
<Human-Readable-Field-Name>: <Value>
...

## Acceptance Criteria
- A Markdown list of acceptance criteria.

## Tasks
- [Optional JIRA-ID] Title of the first task.
  ## Description
  An optional, indented description for this specific task.
  
  ## Fields
  # Fields here override those inherited from the parent ticket.
  <Human-Readable-Field-Name>: <Overridden-Value>
  
  ## Acceptance Criteria
  - Optional, indented acceptance criteria for the task.

- [Optional JIRA-ID] Title of the second task.
  ...
```

##### **2.2. The `ticketr.yaml` Configuration File Schema**

This file is the bridge between the human-friendly Markdown and the machine-specific Jira API. It will be managed by the user, ideally generated by the new `schema` command.

```yaml
# .ticketr.yaml - Main configuration for Ticketr.
defaults:
  project_key: "PROJ"
  issue_type: "Task"

field_mappings:
  # Maps human-readable names from Markdown's "## Fields" to Jira API IDs.
  "Type": "issuetype"
  "Project": "project"
  "Story Points":
    id: "customfield_10010"
    type: "number" # Discovered by the 'schema' command.
  # ... other mappings

sync:
  pull:
    # Allow-list of fields to fetch from Jira and render in Markdown.
    fields:
      - "Type"
      - "Status"
      - "Assignee"
      - "Sprint"
    
    # Deny-list of noisy metadata fields to never pull.
    ignored_fields:
      - "updated"
      - "created"
```

##### **2.3. Core Domain Model Evolution (`internal/core/domain/models.go`)**

The internal data structures must be refactored to support the new generic model.

```go
package domain

type Ticket struct {
    Title              string
    Description        string
    CustomFields       map[string]string
    AcceptanceCriteria []string
    JiraID             string
    Tasks              []Task
    SourceLine         int
}

type Task struct {
    Title              string
    Description        string
    CustomFields       map[string]string // Task-specific overrides
    AcceptanceCriteria []string
    JiraID             string
    SourceLine         int
}
```

#### **3. The Phased Implementation Roadmap**

This roadmap is divided into three distinct, sequential phases. Each phase delivers a quantum leap in functionality and builds upon the last.

##### **Phase 1: The New Foundation - Generic Model & Configuration**

* **Objective:** Replace the old, rigid architecture with the new, generic `Ticket` model and establish the configuration-driven workflow.
* **Key Tasks:**
    1.  **Refactor Domain Model & Parser:**
        *   Execute the domain model refactoring in `internal/core/domain/models.go` as specified in section 2.3.
        *   Completely rewrite the parser in `internal/adapters/filesystem/file_repository.go`. The new parser must recognize the `# TICKET:` block and support indented `## Description`, `## Fields`, and `## Acceptance Criteria` sections for both parent tickets and child tasks. **This is a breaking change and abandons backwards compatibility.**
    2.  **Implement Field Inheritance Logic:**
        *   Refactor `internal/core/services/story_service.go` (to be renamed `ticket_service.go`). The core processing logic must be updated to calculate the "final fields" for each task by merging the task's specific fields over its parent's fields before passing the data to the adapter.
    3.  **Implement Configuration & CLI Scaffolding:**
        *   Integrate the Cobra and Viper libraries into `cmd/ticketr/main.go`.
        *   Scaffold the new command structure: `ticketr push`, `ticketr pull`, `ticketr schema`.
        *   Implement the Viper logic to read `.ticketr.yaml` and environment variables. Update `docker-compose.yml` to support mounting this config file.

##### **Phase 2: The Schema-Aware "Push" Engine**

* **Objective:** Enable the creation and updating of any ticket type with any custom field, driven by a dynamically discovered schema.
* **Key Tasks:**
    1.  **Implement `schema` Command:**
        *   Build the `ticketr schema` command. It must connect to Jira, call the `/rest/api/2/field` and `/rest/api/2/issue/createmeta` endpoints, and generate a valid `.ticketr.yaml` `field_mappings` section.
    2.  **Implement Dynamic Jira Adapter:**
        *   Refactor the `JiraAdapter` in `internal/adapters/jira/jira_adapter.go`. Its `CreateTicket` and `UpdateTicket` methods must now be fully dynamic. They will receive a `map[string]string` of final fields and use the `field_mappings` from the Viper config to construct the correct JSON payload for the Jira API.
    3.  **Implement State Management:**
        *   Introduce a `.ticketr.state` file (JSON format) to store a SHA256 hash of each ticket's content against its Jira ID.
        *   The `push` command logic in the `ticket_service.go` must be enhanced to check this state file and only issue `Update` API calls for tickets whose content has changed.

##### **Phase 3: Intelligent Bidirectional Synchronization**

* **Objective:** Achieve true "Tickets-as-Code" by implementing a powerful, configurable `pull` command.
* **Key Tasks:**
    1.  **Implement Query-Based `pull` Logic:**
        *   Build out the `ticketr pull` command with support for `--project`, `--epic`, and `--jql` flags.
        *   The `JiraAdapter` will need a new `SearchTickets` method that uses Jira's `/rest/api/2/search` endpoint. This method must dynamically construct the `fields` parameter of the API call based on the `sync.pull.fields` configuration from `.ticketr.yaml`.
    2.  **Implement Markdown Renderer:**
        *   The `pull` service will need a new component responsible for transforming the Jira API response (JSON) back into the canonical Markdown `TICKET` format. This includes reversing the field mappings (Jira ID -> human-readable name) and correctly formatting the `## Fields`, `## Description`, etc., sections.
    3.  **Achieve v1.0 SRS Conformance:**
        *   With the new, robust engine in place, implement the remaining v1.0 requirements (Hierarchical Validation, File-Based Logging, Enhanced Reporting) as final features. They can now be implemented more cleanly on top of the new architecture.

#### **4. Evolution of the Software Requirements Specification (SRS)**

The existing `REQUIREMENTS.md` is now obsolete. It must be updated to a v2.0 specification that reflects this new architecture.

*   **Action Item:** Create `REQUIREMENTS-v2.md`.
*   **Key Changes Required:**
    *   All references to "Story" should be replaced with the generic term "Ticket."
    *   **PROD-001 (File-Based State):** Update to reference the new `# TICKET:` Markdown schema.
    *   **PROD-005 (Rich Task Definitions):** Update to include the `## Fields` section for tasks.
    *   **NFR-001 (Credentials):** Update to specify `.ticketr.yaml` as the primary configuration source.
    *   **Add New Requirements:** Create new, formal requirement IDs for all the new cornerstone features:
        *   `PROD-009`: Hierarchical Field Inheritance
        *   `PROD-010`: Query-Based Pull Synchronization
        *   `USER-004`: Jira Schema Discovery (`schema` command)
        *   `USER-005`: Configurable Pull Verbosity

This document provides the complete recipe. An agent given this plan has a clear vision, defined data structures, a phased execution strategy, and instructions on how to update the project's governing laws. Proceed with Phase 1.